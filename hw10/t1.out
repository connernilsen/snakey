section .text
extern ?error
extern ?input
extern ?print
extern ?print_stack
extern ?equal
extern ?try_gc
extern ?print_heap
extern ?HEAP
extern ?HEAP_END
extern ?set_stack_bottom
global ?our_code_starts_here
  jmp near ?our_code_starts_here_end
align 16
?our_code_starts_here:
  push RBP
  mov RBP, RSP
  ;; Push 6 filler variables
  push 62
  push 62
  push 62
  push 62
  push 62
  push 62
  mov R10, RDI
  ;; Setup native call (0 args)
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  mov RDI, RBP
  call ?set_stack_bottom
  ;; Cleanup stack and restore caller saved registers
  mov RDI, R10
  ;; heap start
  mov QWORD R15, RDI ; Load heap_reg with our argument, the heap pointer
  add QWORD R15, 15 ; Align it to the nearest multiple of 16
  mov R10, 0xfffffffffffffff0
  and QWORD R15, R10 ; by adding no more than 15 to it
  mov RAX, [?HEAP_END] ; Reserving 4 words
  sub RAX, 32
  cmp RAX, R15
  jge near $memcheck_88
  ;; Setup native call (0 args)
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  mov RDI, QWORD R15
  mov RSI, QWORD 32
  mov RDX, QWORD RBP
  mov RCX, QWORD RSP
  call ?try_gc
  ;; Cleanup stack and restore caller saved registers
  mov R15, RAX ; assume gc success if returning here, so RAX holds the new heap_reg value
align 16
$memcheck_88:
  mov QWORD [R15+0], 62
  mov QWORD [R15+8], 62
  mov QWORD [R15+16], 62
  mov QWORD [R15+24], 62
  ;; Setup lambda
  mov QWORD [R15+0], 0
  mov QWORD [R15+8], fun_88
  mov QWORD [R15+16], 0
  ;; Save lambda
  mov RAX, R15
  add R15, 32
  ;; Tag lambda
  add RAX, 5
  mov [RBP-8], RAX ; save (rec) print_heap_4
  mov RAX, [RBP-8]
  ;; Compile lambda (0 args)
  jmp near fun_88_end
align 16
fun_88:
  push RBP
  mov RBP, RSP
  ;; Push 0 filler variables
  ;; Setup native call (0 args)
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  mov RDI, 0
  mov RSI, 0
  mov RDX, [?HEAP]
  mov RCX, R15
  call ?print_heap
  ;; Cleanup stack and restore caller saved registers
  mov RSP, RBP
  pop RBP
  ret
align 16
fun_88_end:
  sub RAX, 5
  ;; Move free vars into lambda
  ;; Tag lambda
  add RAX, 5
  ;; Lambda done
  mov RAX, [?HEAP_END] ; Reserving 4 words
  sub RAX, 32
  cmp RAX, R15
  jge near $memcheck_83
  ;; Setup native call (0 args)
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  mov RDI, QWORD R15
  mov RSI, QWORD 32
  mov RDX, QWORD RBP
  mov RCX, QWORD RSP
  call ?try_gc
  ;; Cleanup stack and restore caller saved registers
  mov R15, RAX ; assume gc success if returning here, so RAX holds the new heap_reg value
align 16
$memcheck_83:
  mov QWORD [R15+0], 62
  mov QWORD [R15+8], 62
  mov QWORD [R15+16], 62
  mov QWORD [R15+24], 62
  ;; Setup lambda
  mov QWORD [R15+0], 4
  mov QWORD [R15+8], fun_83
  mov QWORD [R15+16], 0
  ;; Save lambda
  mov RAX, R15
  add R15, 32
  ;; Tag lambda
  add RAX, 5
  mov [RBP-16], RAX ; save (rec) equal_10
  mov RAX, [RBP-16]
  ;; Compile lambda (2 args)
  jmp near fun_83_end
align 16
fun_83:
  push RBP
  mov RBP, RSP
  ;; Push 0 filler variables
  ;; Setup native call (2 args)
  push RDI
  push RSI
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  mov RDI, [RSP+8]
  mov RSI, [RSP+0]
  call ?equal
  ;; Cleanup stack and restore caller saved registers
  pop RSI
  pop RDI
  mov RSP, RBP
  pop RBP
  ret
align 16
fun_83_end:
  sub RAX, 5
  ;; Move free vars into lambda
  ;; Tag lambda
  add RAX, 5
  ;; Lambda done
  mov RAX, [?HEAP_END] ; Reserving 4 words
  sub RAX, 32
  cmp RAX, R15
  jge near $memcheck_80
  ;; Setup native call (0 args)
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  mov RDI, QWORD R15
  mov RSI, QWORD 32
  mov RDX, QWORD RBP
  mov RCX, QWORD RSP
  call ?try_gc
  ;; Cleanup stack and restore caller saved registers
  mov R15, RAX ; assume gc success if returning here, so RAX holds the new heap_reg value
align 16
$memcheck_80:
  mov QWORD [R15+0], 62
  mov QWORD [R15+8], 62
  mov QWORD [R15+16], 62
  mov QWORD [R15+24], 62
  ;; Setup lambda
  mov QWORD [R15+0], 0
  mov QWORD [R15+8], fun_80
  mov QWORD [R15+16], 0
  ;; Save lambda
  mov RAX, R15
  add R15, 32
  ;; Tag lambda
  add RAX, 5
  mov [RBP-24], RAX ; save (rec) input_20
  mov RAX, [RBP-24]
  ;; Compile lambda (0 args)
  jmp near fun_80_end
align 16
fun_80:
  push RBP
  mov RBP, RSP
  ;; Push 0 filler variables
  ;; Setup native call (0 args)
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  call ?input
  ;; Cleanup stack and restore caller saved registers
  mov RSP, RBP
  pop RBP
  ret
align 16
fun_80_end:
  sub RAX, 5
  ;; Move free vars into lambda
  ;; Tag lambda
  add RAX, 5
  ;; Lambda done
  mov RAX, [?HEAP_END] ; Reserving 4 words
  sub RAX, 32
  cmp RAX, R15
  jge near $memcheck_60
  ;; Setup native call (0 args)
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  mov RDI, QWORD R15
  mov RSI, QWORD 32
  mov RDX, QWORD RBP
  mov RCX, QWORD RSP
  call ?try_gc
  ;; Cleanup stack and restore caller saved registers
  mov R15, RAX ; assume gc success if returning here, so RAX holds the new heap_reg value
align 16
$memcheck_60:
  mov QWORD [R15+0], 62
  mov QWORD [R15+8], 62
  mov QWORD [R15+16], 62
  mov QWORD [R15+24], 62
  ;; Setup lambda
  mov QWORD [R15+0], 2
  mov QWORD [R15+8], fun_60
  mov QWORD [R15+16], 0
  ;; Save lambda
  mov RAX, R15
  add R15, 32
  ;; Tag lambda
  add RAX, 5
  mov [RBP-32], RAX ; save (rec) abs_dec_26
  mov RAX, [RBP-32]
  ;; Compile lambda (1 args)
  jmp near fun_60_end
align 16
fun_60:
  push RBP
  mov RBP, RSP
  ;; Push 2 filler variables
  push 62
  push 62
  mov RAX, RDI
  mov R10, 0
  cmp RAX, R10
  mov RAX, 0xffffffffffffffff
  je near done77_eq
  mov RAX, 0x7fffffffffffffff
align 16
done77_eq:
  mov [RBP-8], RAX ; save binop_29
  mov RAX, [RBP-8]
  mov R10, 0x7
  and RAX, R10
  mov R10, 0x7
  cmp RAX, R10
  mov RAX, [RBP-8]
  jnz near error_not_bool
  mov R10, 0x8000000000000000
  test RAX, R10
  jz near if_false_62
align 16
if_true_62:
  mov RAX, 0
  jmp near done_62
align 16
if_false_62:
  mov RAX, 0
  mov R10, 0x1
  test RAX, R10
  jnz near error_comp_not_num
  mov RAX, RDI
  mov R10, 0x1
  test RAX, R10
  jnz near error_comp_not_num
  mov R10, 0
  cmp RAX, R10
  mov RAX, 0xffffffffffffffff
  jl near done72_cmp
  mov RAX, 0x7fffffffffffffff
align 16
done72_cmp:
  mov [RBP-16], RAX ; save binop_34
  mov RAX, [RBP-16]
  mov R10, 0x7
  and RAX, R10
  mov R10, 0x7
  cmp RAX, R10
  mov RAX, [RBP-16]
  jnz near error_not_bool
  mov R10, 0x8000000000000000
  test RAX, R10
  jz near if_false_64
align 16
if_true_64:
  mov RAX, 2
  mov R10, 0x1
  test RAX, R10
  jnz near error_arith_not_num
  mov RAX, RDI
  mov R10, 0x1
  test RAX, R10
  jnz near error_arith_not_num
  mov R10, 2
  add RAX, R10
  jo near error_overflow
  jmp near done_64
align 16
if_false_64:
  mov RAX, 2
  mov R10, 0x1
  test RAX, R10
  jnz near error_arith_not_num
  mov RAX, RDI
  mov R10, 0x1
  test RAX, R10
  jnz near error_arith_not_num
  mov R10, 2
  sub RAX, R10
  jo near error_overflow
align 16
done_64:
align 16
done_62:
  mov RSP, RBP
  pop RBP
  ret
align 16
fun_60_end:
  sub RAX, 5
  ;; Move free vars into lambda
  ;; Tag lambda
  add RAX, 5
  ;; Lambda done
  mov RAX, [?HEAP_END] ; Reserving 4 words
  sub RAX, 32
  cmp RAX, R15
  jge near $memcheck_10
  ;; Setup native call (0 args)
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  mov RDI, QWORD R15
  mov RSI, QWORD 32
  mov RDX, QWORD RBP
  mov RCX, QWORD RSP
  call ?try_gc
  ;; Cleanup stack and restore caller saved registers
  mov R15, RAX ; assume gc success if returning here, so RAX holds the new heap_reg value
align 16
$memcheck_10:
  mov QWORD [R15+0], 62
  mov QWORD [R15+8], 62
  mov QWORD [R15+16], 62
  mov QWORD [R15+24], 62
  ;; Setup lambda
  mov QWORD [R15+0], 4
  mov QWORD [R15+8], fun_10
  mov QWORD [R15+16], 2
  ;; Save lambda
  mov RAX, R15
  add R15, 32
  ;; Tag lambda
  add RAX, 5
  mov [RBP-40], RAX ; save (rec) t1_46
  mov RAX, [?HEAP_END] ; Reserving 6 words
  sub RAX, 48
  cmp RAX, R15
  jge near $memcheck_29
  ;; Setup native call (0 args)
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  mov RDI, QWORD R15
  mov RSI, QWORD 48
  mov RDX, QWORD RBP
  mov RCX, QWORD RSP
  call ?try_gc
  ;; Cleanup stack and restore caller saved registers
  mov R15, RAX ; assume gc success if returning here, so RAX holds the new heap_reg value
align 16
$memcheck_29:
  mov QWORD [R15+0], 62
  mov QWORD [R15+8], 62
  mov QWORD [R15+16], 62
  mov QWORD [R15+24], 62
  mov QWORD [R15+32], 62
  mov QWORD [R15+40], 62
  ;; Setup lambda
  mov QWORD [R15+0], 2
  mov QWORD [R15+8], fun_29
  mov QWORD [R15+16], 4
  ;; Save lambda
  mov RAX, R15
  add R15, 48
  ;; Tag lambda
  add RAX, 5
  mov [RBP-48], RAX ; save (rec) t2_63
  mov RAX, [RBP-40]
  ;; Compile lambda (2 args)
  jmp near fun_10_end
align 16
fun_10:
  push RBP
  mov RBP, RSP
  mov R10, [RAX+24]
  mov [RBP-8], R10
  ;; Push 4 filler variables
  push 62
  push 62
  push 62
  push 62
  mov RAX, RDI
  mov R10, 0x7
  and RAX, R10
  mov R10, 0x7
  cmp RAX, R10
  mov RAX, RDI
  jnz near error_not_bool
  mov R10, 0x8000000000000000
  test RAX, R10
  jz near if_false_11
align 16
if_true_11:
  mov RAX, -2
  mov R10, 0x1
  test RAX, R10
  jnz near error_arith_not_num
  mov RAX, RSI
  mov R10, 0x1
  test RAX, R10
  jnz near error_arith_not_num
  mov R10, -2
  sar RAX, 1
  imul RAX, R10
  jo near error_overflow
  mov [RBP-16], RAX ; save binop_52
  ;; Setup native call (2 args)
  push RDI
  push RSI
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  mov RDI, [RBP-16]
  call ?print
  ;; Cleanup stack and restore caller saved registers
  pop RSI
  pop RDI
  mov [RBP-24], RAX ; save unary_51
  ;; Setup snake call (2 args)
  push RDI
  push RSI
  ;; No stack align
  mov RAX, [RBP-8]
  mov R10, 0x7
  and RAX, R10
  mov R10, 0x5
  cmp RAX, R10
  mov RAX, [RBP-8]
  jnz near error_should_be_fun
  ;; Check call type for lambda
  sub RAX, 5
  mov R10, [RAX+0]
  sar R10, 1
  cmp R10, 1
  jne near error_arity
  ;; Setup args
  mov RDI, [RBP-24]
  call [RAX+8]
  ;; Cleanup stack and restore caller saved registers
  pop RSI
  pop RDI
  jmp near done_11
align 16
if_false_11:
  ;; Setup native call (2 args)
  push RDI
  push RSI
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  mov RDI, [RSP+0]
  call ?print
  ;; Cleanup stack and restore caller saved registers
  pop RSI
  pop RDI
  mov [RBP-16], RAX ; save unary_57
  ;; Setup snake call (2 args)
  push RDI
  push RSI
  ;; No stack align
  mov RAX, [RBP-8]
  mov R10, 0x7
  and RAX, R10
  mov R10, 0x5
  cmp RAX, R10
  mov RAX, [RBP-8]
  jnz near error_should_be_fun
  ;; Check call type for lambda
  sub RAX, 5
  mov R10, [RAX+0]
  sar R10, 1
  cmp R10, 1
  jne near error_arity
  ;; Setup args
  mov RDI, [RBP-16]
  call [RAX+8]
  ;; Cleanup stack and restore caller saved registers
  pop RSI
  pop RDI
align 16
done_11:
  mov RSP, RBP
  pop RBP
  ret
align 16
fun_10_end:
  sub RAX, 5
  ;; Move free vars into lambda
  mov R10, [RBP-48]
  mov QWORD [RAX+24], R10
  ;; Tag lambda
  add RAX, 5
  ;; Lambda done
  mov RAX, [RBP-48]
  ;; Compile lambda (1 args)
  jmp near fun_29_end
align 16
fun_29:
  push RBP
  mov RBP, RSP
  mov R10, [RAX+24]
  mov [RBP-8], R10
  mov R10, [RAX+32]
  mov [RBP-16], R10
  ;; Push 6 filler variables
  push 62
  push 62
  push 62
  push 62
  push 62
  push 62
  ;; Setup snake call (1 args)
  push RDI
  ;; Stack align
  push 62
  mov RAX, [RBP-8]
  mov R10, 0x7
  and RAX, R10
  mov R10, 0x5
  cmp RAX, R10
  mov RAX, [RBP-8]
  jnz near error_should_be_fun
  ;; Check call type for lambda
  sub RAX, 5
  mov R10, [RAX+0]
  sar R10, 1
  cmp R10, 1
  jne near error_arity
  ;; Setup args
  mov RDI, [RSP+8]
  call [RAX+8]
  ;; Cleanup stack and restore caller saved registers
  add RSP, 8
  pop RDI
  mov [RBP-24], RAX ; save dec_num_67
  mov RAX, [RBP-24]
  mov R10, 0
  cmp RAX, R10
  mov RAX, 0xffffffffffffffff
  je near done54_eq
  mov RAX, 0x7fffffffffffffff
align 16
done54_eq:
  mov [RBP-32], RAX ; save binop_72
  mov RAX, [RBP-32]
  mov R10, 0x7
  and RAX, R10
  mov R10, 0x7
  cmp RAX, R10
  mov RAX, [RBP-32]
  jnz near error_not_bool
  mov R10, 0x8000000000000000
  test RAX, R10
  jz near if_false_32
align 16
if_true_32:
  mov RAX, 0
  mov R10, 0x1
  test RAX, R10
  jnz near error_comp_not_num
  mov RAX, RDI
  mov R10, 0x1
  test RAX, R10
  jnz near error_comp_not_num
  mov R10, 0
  cmp RAX, R10
  mov RAX, 0xffffffffffffffff
  jg near done50_cmp
  mov RAX, 0x7fffffffffffffff
align 16
done50_cmp:
  jmp near done_32
align 16
if_false_32:
  ;; Setup snake call (1 args)
  push RDI
  ;; Stack align
  push 62
  mov RAX, [RBP-16]
  mov R10, 0x7
  and RAX, R10
  mov R10, 0x5
  cmp RAX, R10
  mov RAX, [RBP-16]
  jnz near error_should_be_fun
  ;; Check call type for lambda
  sub RAX, 5
  mov R10, [RAX+0]
  sar R10, 1
  cmp R10, 2
  jne near error_arity
  ;; Setup args
  mov RDI, 0xffffffffffffffff
  mov RSI, [RBP-24]
  call [RAX+8]
  ;; Cleanup stack and restore caller saved registers
  add RSP, 8
  pop RDI
  mov [RBP-40], RAX ; save neg_80
  ;; Setup snake call (1 args)
  push RDI
  ;; Stack align
  push 62
  mov RAX, [RBP-16]
  mov R10, 0x7
  and RAX, R10
  mov R10, 0x5
  cmp RAX, R10
  mov RAX, [RBP-16]
  jnz near error_should_be_fun
  ;; Check call type for lambda
  sub RAX, 5
  mov R10, [RAX+0]
  sar R10, 1
  cmp R10, 2
  jne near error_arity
  ;; Setup args
  mov RDI, 0x7fffffffffffffff
  mov RSI, [RBP-24]
  call [RAX+8]
  ;; Cleanup stack and restore caller saved registers
  add RSP, 8
  pop RDI
  mov [RBP-48], RAX ; save pos_87
  mov RAX, [RBP-40]
  mov R10, 0x7
  and RAX, R10
  mov R10, 0x7
  cmp RAX, R10
  mov RAX, [RBP-40]
  jnz near error_not_bool
  mov R10, 0x8000000000000000
  test RAX, R10
  jz near if_false_35
align 16
if_true_35:
  mov RAX, 0xffffffffffffffff
  jmp near done_35
align 16
if_false_35:
  mov RAX, [RBP-48]
  mov R10, 0x7
  and RAX, R10
  mov R10, 0x7
  cmp RAX, R10
  mov RAX, [RBP-48]
  jnz near error_not_bool
  mov R10, 0x8000000000000000
  test RAX, R10
  jz near if_false_36
align 16
if_true_36:
  mov RAX, 0xffffffffffffffff
  jmp near done_36
align 16
if_false_36:
  mov RAX, 0x7fffffffffffffff
align 16
done_36:
align 16
done_35:
align 16
done_32:
  mov RSP, RBP
  pop RBP
  ret
align 16
fun_29_end:
  sub RAX, 5
  ;; Move free vars into lambda
  mov R10, [RBP-32]
  mov QWORD [RAX+24], R10
  mov R10, [RBP-40]
  mov QWORD [RAX+32], R10
  ;; Tag lambda
  add RAX, 5
  ;; Lambda done
  ;; Setup snake call (0 args)
  ;; No stack align
  mov RAX, [RBP-40]
  mov R10, 0x7
  and RAX, R10
  mov R10, 0x5
  cmp RAX, R10
  mov RAX, [RBP-40]
  jnz near error_should_be_fun
  ;; Check call type for lambda
  sub RAX, 5
  mov R10, [RAX+0]
  sar R10, 1
  cmp R10, 2
  jne near error_arity
  ;; Setup args
  mov RDI, 0x7fffffffffffffff
  mov RSI, 8
  call [RAX+8]
  ;; Cleanup stack and restore caller saved registers
  mov RSP, RBP
  pop RBP
  ret
align 16
?our_code_starts_here_end:
align 16
error_comp_not_num:
  ;; Setup native call (0 args)
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  mov RDI, 1
  mov RSI, RAX
  call ?error
  ;; Cleanup stack and restore caller saved registers
align 16
error_arith_not_num:
  ;; Setup native call (0 args)
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  mov RDI, 2
  mov RSI, RAX
  call ?error
  ;; Cleanup stack and restore caller saved registers
align 16
error_not_bool:
  ;; Setup native call (0 args)
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  mov RDI, 3
  mov RSI, RAX
  call ?error
  ;; Cleanup stack and restore caller saved registers
align 16
error_not_tuple:
  ;; Setup native call (0 args)
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  mov RDI, 6
  mov RSI, RAX
  call ?error
  ;; Cleanup stack and restore caller saved registers
align 16
error_get_low_index:
  ;; Setup native call (0 args)
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  mov RDI, 7
  mov RSI, RAX
  call ?error
  ;; Cleanup stack and restore caller saved registers
align 16
error_get_high_index:
  ;; Setup native call (0 args)
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  mov RDI, 8
  mov RSI, RAX
  call ?error
  ;; Cleanup stack and restore caller saved registers
align 16
error_tuple_access_not_num:
  ;; Setup native call (0 args)
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  mov RDI, 16
  mov RSI, RAX
  call ?error
  ;; Cleanup stack and restore caller saved registers
align 16
error_overflow:
  ;; Setup native call (0 args)
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  mov RDI, 5
  mov RSI, RAX
  call ?error
  ;; Cleanup stack and restore caller saved registers
align 16
error_nil_deref:
  ;; Setup native call (0 args)
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  mov RDI, 9
  mov RSI, RAX
  call ?error
  ;; Cleanup stack and restore caller saved registers
align 16
destructure_invalid_len:
  ;; Setup native call (0 args)
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  mov RDI, 4
  mov RSI, RAX
  call ?error
  ;; Cleanup stack and restore caller saved registers
align 16
error_should_be_fun:
  ;; Setup native call (0 args)
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  mov RDI, 14
  mov RSI, RAX
  call ?error
  ;; Cleanup stack and restore caller saved registers
align 16
error_arity:
  ;; Setup native call (0 args)
  ;; No stack align
  ;; Skip call type check for native func
  ;; Setup args
  mov RDI, 15
  mov RSI, RAX
  call ?error
  ;; Cleanup stack and restore caller saved registers

